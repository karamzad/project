import sys
from pyrocko import util
import numpy as np
from pyrocko import gf, io, util, trace, pile, model, orthodrome
import matplotlib.pyplot as plt
import math
from matplotlib.patches import Circle, Arrow
from utilities import *
import matplotlib.animation as animation



def read_model(fn_param):
    lines_p = [line.strip() for line in open(fn_param)] 
    return  np.loadtxt(lines_p)
    
def read_misfit(fn_misfit):
    lines_mis = [line.strip() for line in open(fn_misfit)] 
    return np.loadtxt(lines_mis)
    
def plot_misfit(misfit):   
    x_misfit = np.arange(0, len(misfit))
    plt.figure(1000, figsize=(20., 14))
    plt.subplot(211)
    plt.plot(x_misfit, misfit)
    plt.title('Misfit values for tested models', fontsize=18)
    plt.xlim( (0, len(misfit)))
    plt.xlabel('Model Nr', fontsize=18)
    plt.ylabel('Misfit', fontsize=18)

    plt.subplot(212)
    plt.title('Histogram of misfit values', fontsize=18)
    plt.hist(misfit)
    plt.xlabel('Misfit Bin', fontsize=18)
    plt.ylabel('Nr.', fontsize=18)
    plt.show()
    
def plot_stations(lats, lons, ind):
    plt.figure(ind)
    plt.plot(lons, lats, '*')
    plt.xlabel('lon(degree)')
    plt.ylabel('lat(degree)')
    plt.xlim([0, 90])
    plt.ylim([0, 90])

def all_plot_stations( best_model_param_forplot, ind_lat, ind_lon ):
    n_lowest = len( best_model_param_forplot)
    for i in range(0, n_lowest):
        lat_plot = best_model_param_forplot[i][ind_lat]
        lon_plot = best_model_param_forplot[i][ind_lon]
        plot_stations(lat_plot, lon_plot, i)
               
        
def random_conf(Ns):
    lats=np.random.uniform(20,40,Ns)                                                
    lons=np.random.uniform(20,40,Ns)                                                
    lats = np.around(lats, decimals=1)                                              
    lons = np.around(lons, decimals=1)                                              
    dis=np.zeros([Ns,Ns])                                                           
                                                                 
    for i in range(0,Ns):                                                           
        dis[i] = orthodrome.distance_accurate50m_numpy(lats, lons, lats[i], lons[i])                                                                   
    dis /= 1000.0                                                                   
    dis = np.around(dis, decimals=0)                                                                                                                            
                                                                                
    iu1 = np.triu_indices(Ns)                                                       
    dis[iu1]=0                                                                      
                                                                                
    ar_mindis = dis[np.nonzero(dis)].min()                                          
    ar_aperture = dis[np.nonzero(dis)].max()
    return lats, lons, ar_mindis, ar_aperture

# INPUT FILE NAMES:        
# fn_param :  file that contains all of the model parameters generated by Dinver.
fn_param = sys.argv[1]
# fn_misfit : file that contains all of the misfit values that are generated by Dinver for model parameters. 
fn_misfit = sys.argv[2]
# nsta number of stations
nsta = int(sys.argv[3])

model_param = read_model(fn_param)
misfit = read_misfit(fn_misfit)

nsource = 10

ind_lat = np.arange(0, 2*nsta, 2)
ind_lon = np.arange(1, 2*nsta, 2)


lowest_misfit_index = misfit.argsort()[:1]
lowest_misfit = misfit[lowest_misfit_index]
print lowest_misfit, lowest_misfit_index, nsta
best_model_param = model_param[lowest_misfit_index]


lowest_misfit_index_forplot = misfit.argsort()[:4]
best_model_param_forplot = model_param[lowest_misfit_index_forplot]

#all_plot_stations( best_model_param_forplot, ind_lat, ind_lon )

SE = np.zeros([nsource])

Slat = np.array([10.0, 12.0, 11.0, 10.5, 11.2, 12.6, 9.8, 10.2, 12.1, 10.5])
Slon = np.array([80.0, 81.5, 79.5, 80.6, 81.1, 79.4, 80.7, 79.1, 79.5, 81.4])
Sdepth = np.array([20000., 15000, 12000, 11000, 25000, 13000, 20000, 18000, 22000, 15000 ])
Sstrike = np.array([ 22., 120., 80., 25., 30., 170., 23., 56., 27., 18.])
Sdip = np.array([12.0, 20., 30., 40., 10., 50., 8., 30., 40.,50.])
Srake = np.array([56.7, 10.0, 50.0, 15.0, 20.0,10.0, 40.0,30.5,15., 48.5])
Smag = np.array([7.1, 6.7, 6.1, 5.7, 5.5, 5.3, 5.1, 4.9, 4.8, 4.7])
SE = np.zeros([nsource])
sources = [
    gf.DCSource(
        time = util.str_to_time('2008-02-17 11:06:01.10'),
        lat = Slat[i],
        lon = Slon[i],
        depth = Sdepth[i],
        strike = Sstrike[i],
        dip = Sdip[i],
        rake = Srake[i],
        magnitude = Smag[i] ) for i in range(nsource)]


sy = np.linspace(-0.0001, 0.0001, 50)
sx = np.linspace(-0.0001, 0.0001, 50)

deltat = 10.0/2.
        
which=1
for model_i in range(0, best_model_param.shape[0]):
    traces = []
    P = []
    
    if which == 0:
         lat = best_model_param[model_i][ind_lat]
         lon = best_model_param[model_i][ind_lon]
    else:
         lat, lon, ar_mindis, ar_aperture = random_conf(10)

    for it in range(0, nsource):
        SE[it] = Cost(lat, lon, nsta, it, sources, sx, sy, deltat)

        
        targets = [
           gf.Target(
            codes=('', 'STA%03i' % i, '%03i' % i, 'Z'), lat=lat[i], lon=lon[i],
            store_id='global_2s') for i in range(nsta)]
        source_i = it
        s = sources[it]
        traces, store = GTrace(targets, s)
      #  print traces[0].ydata.max()
        traces_min_time, traces_max_time, order_trace = TrTimeMinMax(traces)      
        P_wind_i, P_wind_e, t_op, center =  window(lat, lon, s.lat, s.lon, s.depth, nsta, store)         
        traces_a = array_extend(nsta, traces_min_time, traces_max_time, traces, P_wind_i, P_wind_e)
#traces_s = array_extend(nsta,traces_min_time, traces_max_time, traces, S_wind_i, S_wind_e)
        #trace.snuffle(traces_a + traces)
        traces_b = array_normalized(traces_a, nsta)
      #  trace.snuffle(traces_b + traces_a)
        P, delay = ArrayBeamForming(
              sx, sy, traces_b, P_wind_i[center], P_wind_e[center], nsta, center, lat, lon, t_op, deltat)
        P = P.transpose()
        BeamShow = AbeamShow(power=P, sx=sx, sy=sy)
        IndexMaxX, IndexMaxY = BeamShow.MaxPower()
        BeamShow.PowerQuality(5, 10) 
        Quality = BeamShow.Ql
        BeamShow.Draw(source_i*10)
        BeamShow.DrawCircle(1e-5)
        BeamShow.DrawArow()
        BeamShow.saveplot(source_i*10+1)
        dum3 = trace.Trace(
               '', '', 'Beam', '', tmin=traces_min_time, deltat=traces[0].deltat,
              ydata=np.zeros(int((traces_max_time - traces_min_time)/traces[0].deltat)))
    
        traces_d, dela = array_beam_s(center, lat, lon, sy[IndexMaxY], sx[IndexMaxX], traces, dum3)

 
        plt.show()  

    EE = np.power(np.sum(np.power(SE,10)), 1./10)  

    print EE
    




